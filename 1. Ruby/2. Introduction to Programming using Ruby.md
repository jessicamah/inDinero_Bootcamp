# Introduction To Programming (Duration: 1 week)
## Basic Programming Knowledge (Maynard)
### 1. Data source and storage
#### Literals
Literals are data/values that are hard coded in the source file. Examples are number (`3`), string (`"hello"`), array (`[1,2,3]`) and hash (`{ :key => 'value' }`) literals.

In this code,
` x = 5 `,
the value of `x` is *literally* `5`. Compare that to
` x = y `,
where the value of x is **not** literally `y`, but what the value of `y` is. That's because `y` is not a literal (it could be a method or variable)

#### Variables
Variables are used to store values for later reference. Since **Ruby** is a *loosely typed* language, you can assign any data type to a variable.

```
x = 123
x = "hello"
x = { :key => value }
x = [1, 2, 3]
```

In Ruby, a variable is *defined* the moment that it is *passed* in the code (not necessarily executed or assigned a value). Variables have an initial value of `nil` until they are assigned a different value.

```
> puts abc
NameError: undefined local variable or method `abc' for main:Object
> if false
>   abc = 123
> end
> puts abc # abc == nil, and nil is printed as emptry string

> abc = 234
> puts abc
234
```

#### Methods
Methods are sets of expressions that return a value. They are commonly used for abstraction, isolation and reuse of code. Methods in Ruby are either *instance* or *class* methods. Instance methods are defined by:
```
def method_name
end
```
Class methods are defined by:
```
def self.method_name
end
```
Here's an example of a class with an instance and a class method, and how they are used:
```
class Sample
  def instance_method
    puts 'this is an instance method'
  end
  
  def self.class_method
    puts 'this is a class method'
  end
end

> Sample.class_method
this is a class method
> a = Sample.new
> a.instance_method
this is an instance method
```
Methods can be called with or without parentheses. Generally, methods without parameters are called without parentheses and methods with parameters are called with parentheses:
```
a = do_something
b = do_something_else(1, 2)
```
All methods return a value. The returned value is always the last evaluated expression/statement, or `nil` if there is none.
```
def empty_method
end

def implied_return_method
  a = 1
  a + 2
end

def explicit_return_method
  a = 5
  return a
  a - 1
end

> empty_method
nil
> implied_return_method
3
> explicit_return_method
5
```

### 2. Data Transformation/Manipulation
#### Number Transformation/Manipulation
Manipulation, computation and transformation of numbers is a basic task in most languages. Since numbers are also objects in ruby, we need very little external methods for manipulating numbers:
```
# The usual stuff
> 1 + 2
3
> 1 - 2
-1
> 1 * 2
2
> 2 / 2
1
> 9 % 4
1

# Note: integer divison is performed if both are integers
> 5 / 2
2
> 5.0 / 2
2.5
> a = 5
> a / 2
2
> a.to_f / 2 # to_f converts to float
2.5
> a / 2.to_f
2.5

# ** is used to raise to the power of
> 3 ** 4
81

# external methods
> Math.sqrt(2)
1.4142135623730951
> Math.log(2)
0.6931471805599453
> Math.sin(2)
0.9092974268256817

# For huge numbers and to avoid floating point division errors, use BigDecimal
> 1.1 / 10
0.11000000000000001 # wrong, it should be 0.11 only
> a = BigDecimal('1.1')
> b = BigDecimal('10')
> (a / b).to_f
0.11
```
#### Content Transformation/Manipulation (for strings, hashes, arrays, etc.)
Content transformation involves manipulation of data structures and other date types. String manipulation is a basic necessity. Manipulation of data structures like arrays and hashes are also needed when handling complex data.
String manipulation:
```
> a = "Sample String"
> a.length
13
> a[0] # just like accessing an array
"S"
> a[-1] # index -1 is the last letter
"g"
> a[0..1] # can get substring
"Sa"
> a[0..-1]
"Sample String"
> a[0..-2]
"Sample Strin"
> a.split(' ') # split by space
["Sample", "String"]

> a.index('S') # finds index of first occurrence
0
> a.index('t')
8
> a.index('le')
4
> a.index('H')
nil

> a.gsub('S', 'X') # replace all occurence (new String object)
"Xample Xtring"
> a[1] = 'X' # replace character(s) in index (on the object itself)
> a
"Xample String"
> a = 'Sample String'
> a[0..1] = 'Xe'
"Xemple String"
> a = 'Sample String'
> a.concat(' Test') # combine strings
> a
"Sample String Test"

# String interpolation (note: must use double quotes)
> num = 10
> a = "This is the number: #{num}"
> a
"This is the number: 10"
```
Hash and Array manipulation are discussed later on.
#### Form Transformation/Manipulation (for others like hash to pdf)
Form transformation involves transforming data from one form to another, like from hash to array or parsing strings as hash. This can also be rendering hashes and arrays as pdf files or web pages. Knowledge of the different forms of data and the way they are stored and represented in different data structures and output formats are needed to for data transformation. Iterators like `each` and `map` are useful tools for writing concise code and simplify these transformations.

### 3. Data persistence and retrieval
#### persistence / saving
#### retrieval

### 4. Data presentation
#### printing to console
#### generating / displaying web pages
#### creating files

## Ruby Introduction
### 1. Data structures (Maynard)
#### Arrays
#### Dictionaries (i.e. Hashtables)
Dictionaries are used to store key-value pairs. Given a key, it returns an associated value. In Ruby, a Hash object is used to store key-value pairs. the Hash class is an implementation of a HashTable, which is a kind of Dictionary.
Hash manipulation:
```
> a = {} # create a hash
{}
> a[:key] = 'value' # assigning a value
> a[:key] # fetch value
'value'
> a.keys # get all keys
[:key]
> a.values # get all values
['value']
> a.delete(:key) # delete entry
> a
{}
```
#### Trees
#### Enums
  
### 2. Variable Scoping (Maynard)
#### Global ($)
#### Class (@@)
#### Instance (@)
#### Local (within methods, blocks and loops)

### 3. Conditionals (Jayson)
#### If Else
if expressions are used for conditional execution. The values false and nil are false, and everything else are true. Notice Ruby uses elsif, not else if nor elif.

Executes code if the conditional is true. If the conditional is not true, code specified in the else clause is executed.
```
> num = 2
> # if syntax
> if num % 2 == 0
> puts "2 is even"
> end
2 is even

> # if else syntax
> x=1
> if x>2
>  puts "x is less than 2"
> else
>  puts "x is greater than 2"
> end
x is less than 2

> #elsif syntax
> number = -5
> if number % 2 == 0
>   puts "#{number} is an even number"
> elsif number < 0
    puts "#{number} is a negative number"
> else
>   puts "#{number} is an odd number"
> end
-5 is a negative number
```

#### Unless
Executes code if conditional is false. If the conditional is true, code specified in the else clause is executed.
```
> # unless syntax
> allowed_person = ["Lebron", "Carmelo", "Durant"]
> unless allowed_person.include?("Robin Williams")
>   puts "You are not a NBA superstar"
> else
>   puts "Welcome bruh"
> end
You are not a NBA superstar
```

### 4. Loops and Iterators (Jayson)

###Why Loop?
Just imagine you needed a program to do something 10 times. You could copy and paste the code 10 times, not to mention slow and pointless. Or, you could tell the computer to repeat a bit of code between point A and point B, until the time comes that you need it to stop. Such a thing is called a loop.

#### Loops
Loops in Ruby are used to execute the same block of code a specified number of times.

#### Loop
It is the simpliest form of loop in ruby.

```
> 5.times { puts "Foo" }
Foo
Foo
Foo
Foo
Foo

> loop { puts "Hello World" } #produces infinite loop
Hello World
Hello World
Hello World
Hello World
Hello World
...
```

#### While Loop
Executes the passed code block repeatedly while the condition is satisfied. 
```
> i = 0
> while i < 5 do
>   puts "Hello Phillipines"
>   i += 1
> end
Hello Phillipines
Hello Phillipines
Hello Phillipines
Hello Phillipines
Hello Phillipines
```

#### Until Loop
The code block is repeatedly executed until the condition is satisfied.
```
> cnt = 0
> until cnt > 5 do
>   puts "Number: #{cnt}"
>   cnt += 1
> end
Number: 0
Number: 1
Number: 2
Number: 3
Number: 4
Number: 5
```



#### Each
Calls the given block once for each element in self and pass its element as a parameter.
```
> #for Arrray
> friends = ["Maynard", "Julian", "Emmanuel"]
> friends.each{|friend| puts "My Friend #{friend}."}
My Friend Maynard.
My Friend Julian.
My Friend Emmanuel.
=> ["Maynard", "Julian", "Emmanuel"]

> #for Hash
> hash = {brand: "suzuki", model: "alto", color: "red"}
> hash.each do |key, value|
>  puts "#{key}: #{value}"
> end
brand: suzuki
model: alto
color: red
=> {:brand=>"suzuki", :model=>"alto", :color=>"red"}
```

#### Each with index
Same as #each, but passes the index of the element instead of the element itself.

```
> #for Arrray
> array1 = [ "a", "b", "c" ]
> array1.each_index {|elem| puts "#{elem} --" }
0 --
1 --
2 --
=> ["a", "b", "c"]


```

#### Select
Returns a new array containing all elements of ary for which the given block returns a true value.
```
> #for Arrray
> num_array = [1, 2, 3, 4, 5, 9, 7]
> even_num = num_array.select
=> [2, 4]
> puts even_num
2
4
=> nil

> #Hash
> h = {d: 1, c: 2, l: 3}
> h.select{|s, k| k.even?}
=> {:c=>2}
```

#### Map
Invokes the given block once for each element of self. Creates a new array containing the values returned by the block.
```ruby
> num_arr = [1,2,3]
> num_arr.map {|x| x + 1 }
#=> [2,3,4]
> puts num_arr
1
2
3
=> nil
> num_arr.map! {|x| x + 1 } #eager loading, the changes will apply to each element of the array
=> [2, 3, 4]
> puts num_arr
2
3
4
=> nil
```
#### Break
Causes unconditional termination of a code block or while or until block, with control transfered to the line after the block. If given an argument, returns that argument as the value of the terminated block.
```
> i = 5
> while i > 0 do
>  puts "Print me Thrice"
>  if i == 3
>    break
>  else
>    i -= 1
>  end
> end
Print me Thrice
Print me Thrice
Print me Thrice
=> nil
```

#### Next
Bumps an iterator, or a while or until block,to the next iteration, unconditionally and without executing whatever may remain of the block.
```
> num_array = [1,2,3,4,5,6,7,8,9]
> num_array.each do |num|
>   if num.even?
>     next
>   else
>     puts num
>   end
> end
1
3
5
7
9
=> [1, 2, 3, 4, 5, 6, 7, 8, 9]
```


### 5. Methods in Ruby (Raymond)
### Class And Instance Method
####What is a Class in General?

A class is the blueprint from which individual objects are created.

Think of class as a *Vehicle*, having several characteristics like *color*, *number of doors*, *number of wheels*, *horse power*,*passenger capacity* and so on...

This characteristics serves as the data members of the class *Vehicle*. With this, you can differentiate different kinds of *Vehicles*.

A *Vehicle* can also have certain functionalities like *move forward*, *move backward*, *turn left*, *turn right*, *stop* and so on...

Definition of A Class:

```
Class Vehicle
{
   Characters color
   Number no_of_doors
   Number no_of_wheels
   Number horsepower
   Number capacity
   Function moveForward
   {
   }
   Function moveBackward
   {
   }
}
```
Playing with the data members of the *Vehicle* class could give you different kinds of vehicles with varying characteristics. For instance, an airplane has three wheels and two doors, red for color, 1000 for its horse power and a passenger capacity of 300 while a car has four wheels and four doors, blue for color, 500 for its horse power and a passenger capacity of 5.

####Definition And Declaration of Classes in Ruby
The ruby language is a pure object oriented language. Almost everything in ruby appears as an object. A class is an object in itself also, that is an instance of the Class class. When you define a class, you define a blueprint for a datatype. Essentially, what the class consists of and what operations you can do with such an object.

Definition of Class in Ruby:
```
class Vehicle
    def some_method
    end
end
```
Class names starts with a *capital* letter, *camel cased*.Class methods, on the other hand, starts with a *small letter*, snake cased.

Declaration of Class in Ruby:
```
car = Vehicle.new
plane = Vehicle.new
```

####Class Initialization

One can pass variables to the *new* method of a class object and be used to initialize class variables.
If a variable is passed to a *new* method of a class object, an *initialize* method is needed to be present in the class in order for the initialization to work. Think of this as class constructors in other languages.
```
class SomeClass
    def initialize(some_initializing_value)
        @some_variable = some_initializing_value
    end
end
a = SomeClass.new(1)
```

####Types of Variables In A Ruby Class
* *Local Variables* are variables that are defined in a method and are *not* available outside the method. In short, Local variables are *only available inside the class method* itself only. Local variables begin with a lowercase letter or _.
```
class SomeClass
    def some_method
        some_local_variable = 1 #local variable here
    end
end
```
* *Instance Variables* are available across methods for any particular instance or object. Plain to say that an instance variables are *available anywhere inside one instance of a class*. Instance variables are preceded by the at sign (@) followed by the variable name.
```
class SomeClass
    def initialize
        @some_instance_variable = 1 #instance variable here
    end
    def some_method
        puts @some_instance_variable #displays the value of the instance variable
    end
end
```
* *Class Variables* are available across different objects. Simply put, a class variable belongs to all instances of the same class. They are preceded by the sign @@ and are followed by the variable name.
```
class SomeClass
    @@some_class_variable = 0
    def increment_class_variable
        @@some_class_variable += 1
    end
    def display_class_variable
        puts @@some_class_variable
    end
end
a = SomeClass.new
b = SomeClass.new
a.increment_class_variable
b.display_class_variable
1 #output
```
* *Global Variables* are available across classes. For instance, a global variable will be available to different instances of a class object. The global variables are always preceded by the dollar sign ($).
```
$some_global_variable = 10
class SomeClassWithGlobalVariable
    def some_method
    end
end
class SomeClass
    def display_global_variable
        puts $some_gloval_variable
    end
end
s = SomeClass.new
s.display_global_variable
10 #output
```

####Accessor and Setter Methods
To make the variables available outside of the class, variables must be defined within the *accessor methods* or commonly *called getter* methods.
```
class SomeClass
    def initialize(x,y)
        @x_axis, @y_axis = x, y
    end
    #accessor methods
    def x_axis
        @x_axis
    end
    def y_axis
        @y_axis
    end
end
a = SomeClass.new(0,100)
puts a.y_axis
100 #output
```

*Setter methods*, on the other hand, is way of Ruby to access and change values of class variables.
```
class SomeClass
    def initialize(x,y)
        @x_axis, @y_axis = x, y
    end
    #accessor methods
    def x_axis
        @x_axis
    end
    def y_axis
        @y_axis
    end
    def set_x_axis=(x_axis)
        @x_axis = x_axis
    end
    def set_y_axis=(y_axis)
        @y_axis = y_axis
    end
end
a = SomeClass.new(0,100)
a.set_x_axis = 200
puts a.x_axis
200 #output
```

###Instance Methods
Instance methods are defined the same way we define any other method by using *def* keyword. Instance method can also be use for all other things as per your requirement.
```
class SomeClass
    def initialize(x,y)
        @x = x
        @y = y
    end
    #instance  Methods
    def add_x_y
        x + y
    end
end
a = SomeClass.new(10,20)
puts a.add_x_y
30 #output
```

###Class Methods
Class Methods are methods that are defined *not* on the instance of a class but on the context of the class itself. Class Methods doesn't have access to instance methods and variables. The keyword *self* denotes that the method is a class method else its an instance method.
```
class SomeClass
    def self.some_class_method
        puts 'HELLO!'
    end
end
SomeClass.some_class_method
HELLO! #output
```

###Method Access Controls
Ruby gives you three levels of protection at instance methods level which may be public, private, or protected. Ruby does not apply any access control over instance and class variables.
* *Public Methods* can be called by anyone. Methods are public by default except for initialize, which is always private.
```
class SomeClass
    #public class
    def some_public_method
        puts 'HELLO!'
    end
end
```
* *Private Methods* can only be accessed by data members of a class instance itself
```
class SomeClass
    def some_private_method #private class
        puts 'Hello!'
    end
    private :some_private_method #this guy makes the above meth private
end
a = SomeClass.new
a.some_private_method #results to a NoMethodError `<main>': private method `name'
```
* *Protected Methods* can only be accessed by data members of a class instance itself and can also be accessed by sub classes or class inheritors but only with the keyword self.
```
class SomeClassWithProtect
    private
    def name
        p "My name is..."
    end
    protected
    def last_name
        p "my last name is ..."
    end
end
load 'SomeClassWithProject'
class SomeClass < SomeClassWithProtect
    def display
        self.last_name
    end
end
a = SomeClass.new
a.display # 'my last name is ...'
```
###Class Inheritance
Inheritance is one of the most useful concepts in Object Oriented Programming (OOP). This allows us to define a new class in terms of another class. Plainly, A newly created class can have data members of another class. The inheriting class is called *derived class* or *sub-class* while on the other hand the existing class inherited from is the *base class* or the *super class*.
```
#super class
class Box
    def initialize(height,width)
        @height, @width = height, width
    end
    def compute_area
        @height * @width
    end
end
#sub-class
load 'box.rb'
class BigBox < Box
    def print_area
        @area = compute_area #inherited method from Box super class
    end
end
b = BigBox.new(2,3)
p b.print_area # 6
```
###Class Method Overriding
Class method overriding is the act of modifying an inherited class method from a super class.
```
#super class
class Box
    def initialize(height,width)
        @height, @width = height, width
    end
    def compute_area
        @height * @width
    end
    def display_height
        puts @height
    end
end
#sub-class
load 'box.rb'
class BigBox < Box
    def print_area
        @area = compute_area
    end
    def display_height
        puts "Box height is #{@height}"
    end
end
b = BigBox.new(2,3)
b.display_height # Box height is 2
```
###Class Freezing
Freezing is used whenever you want to ensure that values won't get changed during the course of your code.
```
class Animal
    def initialize(biting_force, animal_type)
        @biting_force = biting_force
        @animal_type = animal_type
    end
    def get_biting_force
        @biting_force
    end
    def get_animal_type
        @animal_type
    end
    #setter meths
    def set_biting_force=(value)
        @biting_force = value
    end
    def set_animal_type=(value)
        @set_animal_type = value
    end
end
dog = Animal.new(100,'canine')
dog.freeze
if (dog.frozen?)
    puts 'Dog class is a frozen object.'
else
    puts 'Dog class is normal object.'
end
#try to modify the values
dog.set_animal_type = 'cat'
dog.set_biting_force = 900
#retrieve the values
type = dog.get_animal_type
bite = dog.get_biting_force
puts "Dog bitting force is #{dog.get_biting_force}"
puts "Dog type is #{dog.get_animal_type}"
# `set_animal_type=': can't modify frozen Animal (RuntimeError)
```
###Class Constants
A constant is used when a class has data member types that is unchanging in nature. You can only access constant values but you can't change it during run-time. You can access constant values by classname::constant.
```
class Constant
    SOME_CONSTANT = 'constant variable'
end
p Constant::SOME_CONSTANT # constant variable
```
p Constant::SOME_CONSTANT
#### Parameters
#### Passing block and yielding

### 6. Procedural Programming (Emmanuel)
### 7. Object-Oriented Programming (Emmanuel)


i = 5
while i > 0 do
puts "Print me Thrice"
if i == 3
break
else
i -= 1
end
end
