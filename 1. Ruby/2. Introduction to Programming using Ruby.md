# Introduction To Programming (Duration: 1 week)
## Basic Programming Knowledge (Maynard)
### 1. Data source and storage
#### Literals
Literals are data/values that are hard coded in the source file. Examples are number (`3`), string (`"hello"`), array (`[1,2,3]`) and hash (`{ :key => 'value' }`) literals.

In this code,
` x = 5 `,
the value of `x` is *literally* `5`. Compare that to
` x = y `,
where the value of x is **not** literally `y`, but what the value of `y` is. That's because `y` is not a literal (it could be a method or variable)

#### Variables
Variables are used to store values for later reference. Since **Ruby** is a *loosely typed* language, you can assign any data type to a variable.

```
x = 123
x = "hello"
x = { :key => value }
x = [1, 2, 3]
```

In Ruby, a variable is *defined* the moment that it is *passed* in the code (not necessarily executed or assigned a value). Variables have an initial value of `nil` until they are assigned a different value.

```
> puts abc
NameError: undefined local variable or method `abc' for main:Object
> if false
>   abc = 123
> end
> puts abc # abc == nil, and nil is printed as emptry string

> abc = 234
> puts abc
234
```

#### methods
Methods are sets of expressions that return a value. They are commonly used for abstraction, isolation and reuse of code.

### 2. Data transformation
#### Math Stuff (for numbers)
#### Content Transformation (for strings, hashes, arrays, etc.)
#### Form Transformation (for others like hash to pdf)

### 3. Data persistence and retrieval
#### persistence / saving
#### retrieval

### 4. Data presentation
#### printing to console
#### generating / displaying web pages
#### creating files

## Ruby Introduction
### 1. Data structures (Maynard)
#### Arrays
#### Dictionaries (i.e. Hashtables)
#### Trees
#### Enums
  
### 2. Variable Scoping (Maynard)
#### Global ($)
#### Class (@@)
#### Instance (@)
#### Local (within methods, blocks and loops)

### 3. Loops and Iterators (Jayson)
#### While loop
#### Each
#### Select
#### Map
#### Break
#### Next

### 4. Conditionals (Jayson)
#### If Else
#### Unless

### 5. Methods in Ruby (Raymond)
### Class And Instance Method
####What is a Class in General?

A class is the blueprint from which individual objects are created.

Think of class as a *Vehicle*, having several characteristics like *color*, *number of doors*, *number of wheels*, *horse power*,*passenger capacity* and so on...

This characteristics serves as the data members of the class *Vehicle*. With this, you can differentiate different kinds of *Vehicles*.

A *Vehicle* can also have certain functionalities like *move forward*, *move backward*, *turn left*, *turn right*, *stop* and so on...

Definition of A Class:

```
Class Vehicle
{
   Characters color
   Number no_of_doors
   Number no_of_wheels
   Number horsepower
   Number capacity
   Function moveForward
   {
   }
   Function moveBackward
   {
   }
}
```
Playing with the data members of the *Vehicle* class could give you different kinds of vehicles with varying characteristics. For instance, an airplane has three wheels and two doors, red for color, 1000 for its horse power and a passenger capacity of 300 while a car has four wheels and four doors, blue for color, 500 for its horse power and a passenger capacity of 5.

####Definition And Declaration of Classes in Ruby
The ruby language is a pure object oriented language. Almost everything in ruby appears as an object. A class is an object in itself also, that is an instance of the Class class. When you define a class, you define a blueprint for a datatype. Essentially, what the class consists of and what operations you can do with such an object.

Definition of Class in Ruby:
```
class Vehicle
    def some_method
    end
end
```
Class names starts with a *capital* letter, *camel cased*.Class methods, on the other hand, starts with a *small letter*, snake cased.

Declaration of Class in Ruby:
```
car = Vehicle.new
plane = Vehicle.new
```

####Class Initialization

One can pass variables to the *new* method of a class object and be used to initialize class variables.
If a variable is passed to a *new* method of a class object, an *initialize* method is needed to be present in the class in order for the initialization to work. Think of this as class constructors in other languages.
```
class SomeClass
    def initialize(some_initializing_value)
        @some_variable = some_initializing_value
    end
end
a = SomeClass.new(1)
```

####Types of Variables In A Ruby Class
* *Local Variables* are variables that are defined in a method and are *not* available outside the method. In short, Local variables are *only available inside the class method* itself only. Local variables begin with a lowercase letter or _.
```
class SomeClass
    def some_method
        some_local_variable = 1 #local variable here
    end
end
```
* *Instance Variables* are available across methods for any particular instance or object. Plain to say that an instance variables are *available anywhere inside one instance of a class*. Instance variables are preceded by the at sign (@) followed by the variable name.
```
class SomeClass
    def initialize
        @some_instance_variable = 1 #instance variable here
    end
    def some_method
        puts @some_instance_variable #displays the value of the instance variable
    end
end
```
* *Class Variables* are available across different objects. Simply put, a class variable belongs to all instances of the same class. They are preceded by the sign @@ and are followed by the variable name.
```
class SomeClass
    @@some_class_variable = 0
    def increment_class_variable
        @@some_class_variable += 1
    end
    def display_class_variable
        puts @@some_class_variable
    end
end
a = SomeClass.new
b = SomeClass.new
a.increment_class_variable
b.display_class_variable
1 #output
```
* *Global Variables* are available across classes. For instance, a global variable will be available to different instances of a class object. The global variables are always preceded by the dollar sign ($).
```
$some_global_variable = 10
class SomeClassWithGlobalVariable
    def some_method
    end
end
class SomeClass
    def display_global_variable
        puts $some_gloval_variable
    end
end
s = SomeClass.new
s.display_global_variable
10 #output
```

####Accessor and Setter Methods
To make the variables available outside of the class, variables must be defined within the *accessor methods* or commonly *called getter* methods.
```
class SomeClass
    def initialize(x,y)
        @x_axis, @y_axis = x, y
    end
    #accessor methods
    def x_axis
        @x_axis
    end
    def y_axis
        @y_axis
    end
end
a = SomeClass.new(0,100)
puts a.y_axis
100 #output
```

*Setter methods*, on the other hand, is way of Ruby to access and change values of class variables.
```
class SomeClass
    def initialize(x,y)
        @x_axis, @y_axis = x, y
    end
    #accessor methods
    def x_axis
        @x_axis
    end
    def y_axis
        @y_axis
    end
    def set_x_axis=(x_axis)
        @x_axis = x_axis
    end
    def set_y_axis=(y_axis)
        @y_axis = y_axis
    end
end
a = SomeClass.new(0,100)
a.set_x_axis = 200
puts a.x_axis
200 #output
```

###Instance Methods
Instance methods are defined the same way we define any other method by using *def* keyword. Instance method can also be use for all other things as per your requirement.
```
class SomeClass
    def initialize(x,y)
        @x = x
        @y = y
    end
    #instance  Methods
    def add_x_y
        x + y
    end
end
a = SomeClass.new(10,20)
puts a.add_x_y
30 #output
```

###Class Methods
Class Methods are methods that are defined *not* on the instance of a class but on the context of the class itself. Class Methods doesn't have access to instance methods and variables. The keyword *self* denotes that the method is a class method else its an instance method.
```
class SomeClass
    def self.some_class_method
        puts 'HELLO!'
    end
end
SomeClass.some_class_method
HELLO! #output
```

###Method Access Controls
Ruby gives you three levels of protection at instance methods level which may be public, private, or protected. Ruby does not apply any access control over instance and class variables.
* *Public Methods* can be called by anyone. Methods are public by default except for initialize, which is always private.
```
class SomeClass
    #public class
    def some_public_method
        puts 'HELLO!'
    end
end
```
* *Private Methods* can only be accessed by data members of a class instance itself
```
class SomeClass
    def some_private_method #private class
        puts 'Hello!'
    end
    private :some_private_method #this guy makes the above meth private
end
a = SomeClass.new
a.some_private_method #results to a NoMethodError `<main>': private method `name'
```
* *Protected Methods* can only be accessed by data members of a class instance itself and can also be accessed by sub classes or class inheritors but only with the keyword self.
```
class SomeClassWithProtect
    private
    def name
        p "My name is..."
    end
    protected
    def last_name
        p "my last name is ..."
    end
end
load 'SomeClassWithProject'
class SomeClass < SomeClassWithProtect
    def display
        self.last_name
    end
end
a = SomeClass.new
a.display # 'my last name is ...'
```
###Class Inheritance
Inheritance is one of the most useful concepts in Object Oriented Programming (OOP). This allows us to define a new class in terms of another class. Plainly, A newly created class can have data members of another class. The inheriting class is called *derived class* or *sub-class* while on the other hand the existing class inherited from is the *base class* or the *super class*.
```
#super class
class Box
    def initialize(height,width)
        @height, @width = height, width
    end
    def compute_area
        @height * @width
    end
end
#sub-class
load 'box.rb'
class BigBox < Box
    def print_area
        @area = compute_area #inherited method from Box super class
    end
end
b = BigBox.new(2,3)
p b.print_area # 6
```
###Class Method Overriding
Class method overriding is the act of modifying an inherited class method from a super class.
```
#super class
class Box
    def initialize(height,width)
        @height, @width = height, width
    end
    def compute_area
        @height * @width
    end
    def display_height
        puts @height
    end
end
#sub-class
load 'box.rb'
class BigBox < Box
    def print_area
        @area = compute_area
    end
    def display_height
        puts "Box height is #{@height}"
    end
end
b = BigBox.new(2,3)
b.display_height # Box height is 2
```
###Class Freezing
Freezing is used whenever you want to ensure that values won't get changed during the course of your code.
```
class Animal
    def initialize(biting_force, animal_type)
        @biting_force = biting_force
        @animal_type = animal_type
    end
    def get_biting_force
        @biting_force
    end
    def get_animal_type
        @animal_type
    end
    #setter meths
    def set_biting_force=(value)
        @biting_force = value
    end
    def set_animal_type=(value)
        @set_animal_type = value
    end
end
dog = Animal.new(100,'canine')
dog.freeze
if (dog.frozen?)
    puts 'Dog class is a frozen object.'
else
    puts 'Dog class is normal object.'
end
#try to modify the values
dog.set_animal_type = 'cat'
dog.set_biting_force = 900
#retrieve the values
type = dog.get_animal_type
bite = dog.get_biting_force
puts "Dog bitting force is #{dog.get_biting_force}"
puts "Dog type is #{dog.get_animal_type}"
# `set_animal_type=': can't modify frozen Animal (RuntimeError)
```
###Class Constants
A constant is used when a class has data member types that is unchanging in nature. You can only access constant values but you can't change it during run-time. You can access constant values by classname::constant.
```
class Constant
    SOME_CONSTANT = 'constant variable'
end
p Constant::SOME_CONSTANT # constant variable
```
p Constant::SOME_CONSTANT
#### Parameters
#### Passing block and yielding

### 6. Procedural Programming (Emmanuel)
### 7. Object-Oriented Programming (Emmanuel)
